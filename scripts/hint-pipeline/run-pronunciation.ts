/**
 * Standalone pronunciation pipeline for level 5+ words.
 * 1. Fetch words from DB (level >= 5)
 * 2. Fetch IPA from Wiktionary
 * 3. LLM fills IPA gaps + generates phonetic respelling for all
 * 4. Output SQL migration
 *
 * Usage: bun scripts/hint-pipeline/run-pronunciation.ts [--dry-run]
 */

import { fetchWords } from './fetch-words';
import { fetchIPAFromWiktionary } from './fetch-ipa';
import { generatePronunciation } from './generate-pronunciation';

const OUTPUT_DIR = new URL('./data/', import.meta.url).pathname;

function escapeSQL(str: string): string {
  return str.replace(/'/g, "''");
}

function today(): string {
  return new Date().toISOString().slice(0, 10);
}

async function main() {
  const dryRun = process.argv.includes('--dry-run');
  console.log('=== SBN Pronunciation Pipeline ===\n');
  console.log(`Options: { dryRun: ${dryRun} }\n`);

  // Step 1: Fetch level 5+ words
  console.log('--- Step 1: Fetch level 5+ words ---');
  const allWords = await fetchWords({ force: true });
  const words = allWords.filter((w) => w.level >= 5);
  console.log(`  Filtered to ${words.length} words (level 5+)\n`);

  // Level distribution
  const levels = new Map<number, number>();
  for (const w of words) {
    levels.set(w.level, (levels.get(w.level) ?? 0) + 1);
  }
  for (const [level, count] of [...levels.entries()].sort((a, b) => a[0] - b[0])) {
    console.log(`  Level ${level}: ${count} words`);
  }
  console.log('');

  // Step 2: Fetch IPA from Wiktionary
  console.log('--- Step 2: Fetch IPA from Wiktionary ---');
  const wiktionaryIPA = await fetchIPAFromWiktionary(words);
  console.log('');

  // Step 3: LLM pronunciation generation
  console.log('--- Step 3: Generate pronunciation (LLM) ---');
  const inputs = words.map((w) => ({
    word: w.word,
    wiktionaryIPA: wiktionaryIPA.get(w.word) ?? null,
  }));

  const pronunciations = await generatePronunciation(inputs, { dryRun });

  if (dryRun) {
    console.log('\n[dry-run] Done.');
    return;
  }
  console.log('');

  // Step 4: Build and write migration
  console.log('--- Step 4: Output ---');

  const lines: string[] = [
    `-- Populate IPA and phonetic respelling for level 5+ words`,
    `-- ${pronunciations.size} words with pronunciation data`,
    `-- IPA sourced from Wiktionary where available, LLM-generated for gaps`,
    `-- Phonetic respelling generated by Claude Haiku 4.5`,
    `-- Generated on ${today()}`,
    ``,
  ];

  // Sort by word for readability
  const sorted = [...pronunciations.entries()].sort((a, b) =>
    a[0].localeCompare(b[0])
  );

  let wiktCount = 0;
  let llmCount = 0;

  for (const [wordLower, p] of sorted) {
    const word = escapeSQL(p.word);
    const ipa = escapeSQL(p.ipa);
    const phonetic = escapeSQL(p.phonetic);
    lines.push(
      `UPDATE spelling_word_bank SET ipa = '${ipa}', phonetic = '${phonetic}' WHERE word = '${word}';`
    );

    if (wiktionaryIPA.has(p.word)) wiktCount++;
    else llmCount++;
  }

  lines.push('');

  const sqlPath = `${OUTPUT_DIR}pronunciation-${today()}.sql`;
  await Bun.write(sqlPath, lines.join('\n'));
  console.log(`Migration SQL: ${sqlPath}`);

  // Also write review JSON
  const reviewData = {
    generated: new Date().toISOString(),
    stats: {
      total: pronunciations.size,
      wiktionaryIPA: wiktCount,
      llmGeneratedIPA: llmCount,
    },
    words: sorted.map(([, p]) => ({
      word: p.word,
      ipa: p.ipa,
      phonetic: p.phonetic,
      ipaSource: wiktionaryIPA.has(p.word) ? 'wiktionary' : 'llm',
    })),
  };

  const jsonPath = `${OUTPUT_DIR}pronunciation-${today()}.json`;
  await Bun.write(jsonPath, JSON.stringify(reviewData, null, 2));
  console.log(`Review JSON: ${jsonPath}`);

  console.log(`\n=== Done ===`);
  console.log(`Total: ${pronunciations.size} words`);
  console.log(`IPA from Wiktionary: ${wiktCount}`);
  console.log(`IPA from LLM: ${llmCount}`);
  console.log(`\nNext: review JSON, then copy SQL to supabase/migrations/ and apply.`);
}

main().catch((err) => {
  console.error('Fatal error:', err);
  process.exit(1);
});
