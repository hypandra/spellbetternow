/**
 * Output hint results as JSON (for review) and SQL migration.
 */

import type { HintResult, ValidationResult } from './types';

const OUTPUT_DIR = new URL('./data/', import.meta.url).pathname;

function today(): string {
  return new Date().toISOString().slice(0, 10);
}

function escapeSQL(str: string): string {
  return str.replace(/'/g, "''");
}

function formatArray(arr: string[]): string {
  if (arr.length === 0) return "'{}'";
  const escaped = arr.map((s) => `"${escapeSQL(s)}"`).join(',');
  return `'{${escaped}}'`;
}

export async function writeReviewJSON(result: ValidationResult): Promise<string> {
  const path = `${OUTPUT_DIR}hints-${today()}.json`;

  const data = {
    generated: new Date().toISOString(),
    stats: {
      clean: result.clean.length,
      leaky: result.leaky.length,
      warnings: result.warnings.length,
    },
    words: result.clean.map((h) => ({
      word: h.word,
      level: h.level,
      part_of_speech: h.part_of_speech,
      not_synonyms: h.not_synonyms,
      letter_fragments: h.letter_fragments,
      rhyme_hints: h.rhyme_hints,
    })),
  };

  await Bun.write(path, JSON.stringify(data, null, 2));
  console.log(`Review JSON: ${path}`);
  return path;
}

export async function writeLeakyJSON(
  result: ValidationResult
): Promise<string | null> {
  if (result.leaky.length === 0) return null;

  const path = `${OUTPUT_DIR}leaky-${today()}.json`;
  const data = result.leaky.map((h) => ({
    word: h.word,
    level: h.level,
    part_of_speech: h.part_of_speech,
    not_synonyms: h.not_synonyms,
    rhyme_hints: h.rhyme_hints,
    failures: h.failures,
  }));

  await Bun.write(path, JSON.stringify(data, null, 2));
  console.log(`Leaky words: ${path}`);
  return path;
}

export async function writeMigrationSQL(hints: HintResult[]): Promise<string> {
  const path = `${OUTPUT_DIR}migration-${today()}.sql`;

  const lines: string[] = [
    `-- Populate text hints for no-audio spelling mode`,
    `-- ${hints.length} words updated with part_of_speech, not_synonyms, letter_fragments, rhyme_hints`,
    `-- Generated by hint-pipeline on ${today()}`,
    ``,
  ];

  // Sort by level then word for readability
  const sorted = [...hints].sort(
    (a, b) => a.level - b.level || a.word.localeCompare(b.word)
  );

  for (const h of sorted) {
    const word = escapeSQL(h.word);
    const pos = escapeSQL(h.part_of_speech);
    const notSyn = formatArray(h.not_synonyms);
    const fragments = formatArray(h.letter_fragments);
    const rhymes = formatArray(h.rhyme_hints);

    lines.push(
      `UPDATE spelling_word_bank SET part_of_speech = '${pos}', not_synonyms = ${notSyn}, letter_fragments = ${fragments}, rhyme_hints = ${rhymes} WHERE word = '${word}';`
    );
  }

  lines.push('');

  await Bun.write(path, lines.join('\n'));
  console.log(`Migration SQL: ${path}`);
  return path;
}
